<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Made on Vibes DIY</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script>
      window.CALLAI_API_KEY = "sk-vibes-proxy-managed";
      window.CALLAI_CHAT_URL = "https://vibes-diy-api.com/";
      window.CALLAI_IMG_URL = "https://vibes-diy-api.com/";
    </script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.1.1/es2022/react.mjs",
          "react-dom": "https://esm.sh/react-dom@19.1.1/es2022/react-dom.mjs",
          "react-dom/client": "https://esm.sh/react-dom@19.1.1/es2022/client.mjs",
          "use-fireproof": "https://esm.sh/use-fireproof@0.23.14?external=react,react-dom",
          "call-ai": "https://esm.sh/call-ai",
          "use-vibes": "https://esm.sh/use-vibes",
          "three": "https://esm.sh/three"
        }
      }
    </script>
    <script type="text/babel" data-type="module">
      import ReactDOMClient from "react-dom/client";

      // prettier-ignore
      import React, { useMemo, useState, useEffect, useRef } from "react";
import { useFireproof } from "use-fireproof";

export default function App() {
  const { useDocument, useLiveQuery, database } = useFireproof("weight-tracker-db");

  // form document for adding entries
  // Use local date to avoid timezone offset issues
  const today = (() => {
    const d = new Date();
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  })();
  const { doc, merge, submit, reset } = useDocument({
    type: "weight-entry",
    date: today,
    weight: "",
    createdAt: Date.now()
  });

  // live query of all docs (query by created timestamp to get all docs)
  const { docs = [] } = useLiveQuery("createdAt", { limit: 1000 });

  // selected item for detail view
  const [selectedId, setSelectedId] = useState(null);

  // time range filter
  const [timeRange, setTimeRange] = useState("ALL"); // ALL, MONTH, QUARTER, YEAR

  // responsive chart sizing
  const chartRef = useRef();
  const [chartWidth, setChartWidth] = useState(360);
  useEffect(() => {
    function resize() {
      if (chartRef.current) {
        setChartWidth(chartRef.current.clientWidth || 360);
      }
    }
    resize();
    window.addEventListener("resize", resize);
    return () => window.removeEventListener("resize", resize);
  }, []);

  // normalize, sort ascending by date for running average calculation
  const entriesAsc = useMemo(() => {
    const filtered = docs
      .filter((d) => d.type === "weight-entry" && d.weight !== "" && d.date)
      .slice()
      .sort((a, b) => {
        const t = new Date(a.date) - new Date(b.date);
        if (t !== 0) return t;
        return (a._id || "").localeCompare(b._id || "");
      });

    // Apply time range filter
    if (timeRange === "ALL") return filtered;

    const now = new Date();
    const cutoff = new Date();

    if (timeRange === "WEEK") {
      cutoff.setDate(now.getDate() - 7);
    } else if (timeRange === "MONTH") {
      cutoff.setDate(now.getDate() - 30);
    } else if (timeRange === "QUARTER") {
      cutoff.setDate(now.getDate() - 90);
    } else if (timeRange === "YEAR") {
      cutoff.setDate(now.getDate() - 365);
    }

    return filtered.filter(e => new Date(e.date) >= cutoff);
  }, [docs, timeRange]);

  // compute EWMA (Exponentially Weighted Moving Average) trend - Hacker's Diet method
  const entriesWithAvgAsc = useMemo(() => {
    const result = [];
    const beta = 0.9; // smoothing factor (90% weight on trend, 10% on new data)
    let trend = null;

    for (let i = 0; i < entriesAsc.length; i++) {
      const e = entriesAsc[i];
      const w = Number(e.weight) || 0;

      // EWMA formula: trend_t = β × trend_(t-1) + (1-β) × weight_t
      if (trend === null) {
        // Initialize trend with first weight
        trend = w;
      } else {
        trend = beta * trend + (1 - beta) * w;
      }

      result.push({ ...e, runningAverage: Number(trend.toFixed(1)), weightNum: Number(w) });
    }
    return result;
  }, [entriesAsc]);

  // for display we want newest first
  const entriesDesc = useMemo(() => {
    return entriesWithAvgAsc.slice().reverse();
  }, [entriesWithAvgAsc]);

  // chart data: x by time, y by weight
  const chartData = useMemo(() => {
    if (entriesWithAvgAsc.length === 0) return null;
    const times = entriesWithAvgAsc.map((e) => new Date(e.date).getTime());
    const minT = Math.min(...times);
    const maxT = Math.max(...times);
    const weights = entriesWithAvgAsc.map((e) => e.weightNum);
    const avgs = entriesWithAvgAsc.map((e) => e.runningAverage);
    const minW = Math.min(...weights.concat(avgs));
    const maxW = Math.max(...weights.concat(avgs));
    return { entries: entriesWithAvgAsc, minT, maxT, minW, maxW };
  }, [entriesWithAvgAsc]);

  // statistics calculations
  const stats = useMemo(() => {
    if (entriesWithAvgAsc.length === 0) return null;

    // Find highest/lowest actual weight
    let highestActual = entriesWithAvgAsc[0];
    let lowestActual = entriesWithAvgAsc[0];
    let highestTrend = entriesWithAvgAsc[0];
    let lowestTrend = entriesWithAvgAsc[0];

    for (const entry of entriesWithAvgAsc) {
      if (entry.weightNum > highestActual.weightNum) highestActual = entry;
      if (entry.weightNum < lowestActual.weightNum) lowestActual = entry;
      if (entry.runningAverage > highestTrend.runningAverage) highestTrend = entry;
      if (entry.runningAverage < lowestTrend.runningAverage) lowestTrend = entry;
    }

    // Calculate streaks (consecutive days)
    const allEntriesSorted = docs
      .filter((d) => d.type === "weight-entry" && d.weight !== "" && d.date)
      .slice()
      .sort((a, b) => new Date(b.date) - new Date(a.date)); // newest first

    let currentStreak = 0;
    let maxStreak = 0;
    let tempStreak = 1;

    if (allEntriesSorted.length > 0) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const mostRecent = new Date(allEntriesSorted[0].date);
      mostRecent.setHours(0, 0, 0, 0);

      // Check if current streak is active (today or yesterday)
      const daysSinceLastEntry = Math.floor((today - mostRecent) / (1000 * 60 * 60 * 24));
      if (daysSinceLastEntry <= 1) {
        currentStreak = 1;

        // Count consecutive days backwards
        for (let i = 1; i < allEntriesSorted.length; i++) {
          const prevDate = new Date(allEntriesSorted[i - 1].date);
          const currDate = new Date(allEntriesSorted[i].date);
          prevDate.setHours(0, 0, 0, 0);
          currDate.setHours(0, 0, 0, 0);

          const dayDiff = Math.floor((prevDate - currDate) / (1000 * 60 * 60 * 24));
          if (dayDiff === 1) {
            currentStreak++;
          } else {
            break;
          }
        }
      }

      // Find longest streak ever
      for (let i = 0; i < allEntriesSorted.length - 1; i++) {
        const prevDate = new Date(allEntriesSorted[i].date);
        const currDate = new Date(allEntriesSorted[i + 1].date);
        prevDate.setHours(0, 0, 0, 0);
        currDate.setHours(0, 0, 0, 0);

        const dayDiff = Math.floor((prevDate - currDate) / (1000 * 60 * 60 * 24));
        if (dayDiff === 1) {
          tempStreak++;
          maxStreak = Math.max(maxStreak, tempStreak);
        } else {
          tempStreak = 1;
        }
      }
      maxStreak = Math.max(maxStreak, tempStreak, currentStreak);
    }

    return {
      highestActual,
      lowestActual,
      highestTrend,
      lowestTrend,
      currentStreak,
      maxStreak
    };
  }, [entriesWithAvgAsc, docs]);

  // calorie delta calculation (7-day trend slope)
  const calorieDelta = useMemo(() => {
    if (entriesWithAvgAsc.length < 7) return null;

    // Get last 7 entries
    const last7 = entriesWithAvgAsc.slice(-7);
    const firstTrend = last7[0].runningAverage;
    const lastTrend = last7[last7.length - 1].runningAverage;
    const firstDate = new Date(last7[0].date);
    const lastDate = new Date(last7[last7.length - 1].date);
    const days = (lastDate - firstDate) / (1000 * 60 * 60 * 24);

    if (days === 0) return null;

    // Calculate lbs/week change
    const lbsPerDay = (lastTrend - firstTrend) / days;
    const lbsPerWeek = lbsPerDay * 7;

    // Convert to calories (1 lb = 3500 calories)
    const caloriesPerDay = Math.round(lbsPerWeek * 3500 / 7);

    return {
      lbsPerWeek: Number(lbsPerWeek.toFixed(2)),
      caloriesPerDay
    };
  }, [entriesWithAvgAsc]);

  // goal calculator - load saved goal from database
  const [goalInput, setGoalInput] = useState("");

  // Find saved goal from docs
  const savedGoal = useMemo(() => {
    return docs.find(d => d.type === "goal-weight");
  }, [docs]);

  const goalWeight = savedGoal?.weight || "";

  // Sync input with saved goal
  useEffect(() => {
    if (savedGoal) {
      setGoalInput(savedGoal.weight);
    }
  }, [savedGoal]);

  // Save goal to database
  const handleSaveGoal = async () => {
    if (!goalInput || isNaN(Number(goalInput))) return;

    if (savedGoal) {
      // Update existing
      await database.put({
        ...savedGoal,
        weight: goalInput,
        updatedAt: Date.now()
      });
    } else {
      // Create new
      await database.put({
        type: "goal-weight",
        weight: goalInput,
        createdAt: Date.now()
      });
    }
  };

  const handleClearGoal = async () => {
    if (savedGoal) {
      await database.del(savedGoal._id);
    }
    setGoalInput("");
  };
  const goalProjection = useMemo(() => {
    if (!goalWeight || !calorieDelta) return null;

    const goal = Number(goalWeight);
    if (isNaN(goal) || entriesWithAvgAsc.length === 0) return null;

    const currentTrend = entriesWithAvgAsc[entriesWithAvgAsc.length - 1].runningAverage;
    const remaining = goal - currentTrend;

    // Determine if we need to lose or gain weight
    const needToLose = remaining < 0;
    const needToGain = remaining > 0;

    // Check if current trend is in the right direction
    const trendingDown = calorieDelta.lbsPerWeek < 0;
    const trendingUp = calorieDelta.lbsPerWeek > 0;

    const wrongDirection = (needToLose && trendingUp) || (needToGain && trendingDown);

    if (wrongDirection) {
      // Calculate how many calories need to change to reverse trend
      const currentCalPerDay = calorieDelta.caloriesPerDay;
      const neededCalChange = Math.abs(currentCalPerDay);

      return {
        wrongDirection: true,
        remaining: Number(remaining.toFixed(1)),
        currentCalPerDay,
        neededCalChange,
        needToLose
      };
    }

    // Trending in right direction - calculate time to goal
    if (calorieDelta.lbsPerWeek === 0) return null;

    const weeksToGoal = remaining / calorieDelta.lbsPerWeek;
    const daysToGoal = Math.round(weeksToGoal * 7);

    const targetDate = new Date();
    targetDate.setDate(targetDate.getDate() + daysToGoal);

    return {
      wrongDirection: false,
      remaining: Number(remaining.toFixed(1)),
      daysToGoal,
      targetDate: targetDate.toISOString().slice(0, 10)
    };
  }, [goalWeight, calorieDelta, entriesWithAvgAsc]);

  // tooltip for chart
  const [tooltip, setTooltip] = useState(null);

  // add entry handler
  const handleAdd = (e) => {
    e.preventDefault();
    if (!doc.date || doc.weight === "" || isNaN(Number(doc.weight))) return;
    merge({ createdAt: Date.now() });
    // submit stores the form doc as a new document and resets the form
    submit();
    // after submit reset date to today for convenience
    setTimeout(() => {
      merge({ date: today, weight: "" });
      reset(); // ensure form cleared
    }, 0);
  };

  // delete entry
  const handleDelete = async (id) => {
    await database.del(id);
    if (selectedId === id) setSelectedId(null);
  };

  // clear all data
  const handleClearAll = async () => {
    if (!confirm("Delete all weight entries? This cannot be undone.")) return;

    const allEntries = docs.filter(d => d.type === "weight-entry");
    for (const entry of allEntries) {
      await database.del(entry._id);
    }
    setSelectedId(null);
  };

  // CSV import handler
  const [importing, setImporting] = useState(false);
  const [importStatus, setImportStatus] = useState(null);

  const handleCSVImport = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    setImporting(true);
    setImportStatus("Reading file...");

    try {
      const text = await file.text();
      const lines = text.split('\n').filter(l => l.trim());

      // Skip header
      const dataLines = lines.slice(1);

      let imported = 0;
      let skipped = 0;

      // Collect entries to import first
      const entriesToImport = [];
      for (const line of dataLines) {
        const parts = line.split(',');
        if (parts.length < 3) continue;

        const date = parts[0].trim();
        const weight = parts[1].trim();
        const isInterpolated = parts[2].trim();

        // Only collect non-interpolated entries
        if (isInterpolated === 'No' && weight && date) {
          entriesToImport.push({ date, weight });
        } else {
          skipped++;
        }
      }

      // Import entries with a small delay to avoid overwhelming Fireproof
      for (let i = 0; i < entriesToImport.length; i++) {
        const { date, weight } = entriesToImport[i];

        // Validate data before import
        if (!date || !weight || isNaN(Number(weight))) {
          skipped++;
          continue;
        }

        setImportStatus(`Importing ${i + 1}/${entriesToImport.length}...`);

        // Parse date and ensure valid timestamp (fallback to current time if invalid)
        const parsedDate = new Date(date + "T00:00:00");
        const timestamp = !isNaN(parsedDate.getTime()) ? parsedDate.getTime() : Date.now();

        // Create clean object with exact same structure as form
        const entry = Object.create(null);
        entry.type = "weight-entry";
        entry.date = date;
        entry.weight = weight;
        entry.createdAt = timestamp;

        // Let Fireproof auto-generate _id to avoid conflicts
        await database.put(entry);
        imported++;

        // Delay between each entry to let Fireproof fully process
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      setImportStatus(`✓ Imported ${imported} entries (skipped ${skipped} interpolated)`);

    } catch (err) {
      setImportStatus(`✗ Error: ${err.message}`);
    } finally {
      setImporting(false);
      e.target.value = ''; // Reset file input
    }
  };

  // small helpers
  const formatDate = (d) => {
    return new Date(d).toLocaleDateString();
  };

  // draw path generator for a numeric array -> SVG path
  const linePath = (points) => {
    if (points.length === 0) return "";
    return points
      .map((p, i) => `${i === 0 ? "M" : "L"} ${p.x.toFixed(2)} ${p.y.toFixed(2)}`)
      .join(" ");
  };

  return (
    <div className="min-h-screen p-4 bg-white">
      <div className="max-w-4xl mx-auto">
        <div className="p-5 rounded-lg shadow-sm border border-gray-200">
          <h1 className="text-2xl font-bold mb-2">Weight Tracker</h1>
          <p className="italic text-sm text-gray-600 mb-4">
            Track your weight over time. Add daily entries and view both the raw measurements and a running-average trend line to see longer-term movement.
          </p>

          {/* Input Form */}
          <form onSubmit={handleAdd} className="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
            <div>
              <label className="block text-xs font-semibold mb-1">Date</label>
              <input
                type="date"
                value={doc.date}
                onChange={(e) => merge({ date: e.target.value })}
                className="w-full px-3 py-2 border rounded"
                required
              />
            </div>

            <div>
              <label className="block text-xs font-semibold mb-1">Weight</label>
              <input
                type="number"
                step="0.1"
                min="0"
                value={doc.weight}
                onChange={(e) => merge({ weight: e.target.value })}
                placeholder="e.g. 71.5"
                className="w-full px-3 py-2 border rounded"
                required
              />
            </div>

            <div className="flex items-end">
              <button
                type="submit"
                className="w-full bg-[#2563eb] text-white py-2 rounded hover:bg-[#1e40af]"
              >
                Add Entry
              </button>
            </div>
          </form>

          {/* CSV Import */}
          <div className="mb-4 p-3 border border-dashed border-gray-300 rounded bg-gray-50">
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm font-semibold mb-1">Import from TrendWeight CSV</div>
                <div className="text-xs text-gray-600">Only non-interpolated entries will be imported</div>
              </div>
              <label className="cursor-pointer bg-gray-200 hover:bg-gray-300 px-4 py-2 rounded text-sm font-medium">
                {importing ? "Importing..." : "Choose File"}
                <input
                  type="file"
                  accept=".csv"
                  onChange={handleCSVImport}
                  disabled={importing}
                  className="hidden"
                />
              </label>
            </div>
            {importStatus && (
              <div className={`mt-2 text-sm ${importStatus.startsWith('✓') ? 'text-green-600' : 'text-red-600'} flex items-center gap-2`}>
                <span>{importStatus}</span>
                <button
                  onClick={() => setImportStatus(null)}
                  className="text-gray-400 hover:text-gray-600"
                  title="Dismiss"
                >
                  ✕
                </button>
              </div>
            )}
          </div>

          {/* Chart */}
          <div className="mb-4">
            <div className="flex items-center justify-between mb-2">
              <h2 className="font-semibold">Weight & Trend</h2>
              <div className="flex items-center gap-2">
                <div className="text-xs text-gray-600 mr-2">
                  Actual — blue • Trend — orange
                </div>
                <div className="flex gap-1">
                  {["ALL", "YEAR", "QUARTER", "MONTH", "WEEK"].map(range => (
                    <button
                      key={range}
                      onClick={() => setTimeRange(range)}
                      className={`px-2 py-1 text-xs rounded ${
                        timeRange === range
                          ? "bg-[#2563eb] text-white"
                          : "bg-gray-100 text-gray-700 hover:bg-gray-200"
                      }`}
                    >
                      {range === "ALL" ? "All" : range === "WEEK" ? "1w" : range === "MONTH" ? "30d" : range === "QUARTER" ? "90d" : "1y"}
                    </button>
                  ))}
                </div>
              </div>
            </div>

            <div ref={chartRef} className="w-full bg-gray-50 border rounded p-2">
              <svg
                width="100%"
                viewBox={`0 0 ${Math.max(360, chartWidth)} 220`}
                className="block"
                preserveAspectRatio="xMinYMin meet"
                onMouseLeave={() => setTooltip(null)}
              >
                <rect x="0" y="0" width="100%" height="100%" fill="transparent" />
                {chartData ? (
                  (() => {
                    const W = Math.max(360, chartWidth);
                    const H = 200;
                    const padX = 40;
                    const padY = 20;
                    const tSpan = chartData.maxT - chartData.minT || 1;
                    const wSpan = chartData.maxW - chartData.minW || 1;

                    // compute scaled points
                    const pointsActual = chartData.entries.map((e) => {
                      const t = new Date(e.date).getTime();
                      const x = padX + ((t - chartData.minT) / tSpan) * (W - padX - 10);
                      const y =
                        padY + (1 - (e.weightNum - chartData.minW) / wSpan) * (H - padY - 30);
                      return { x, y, date: e.date, weight: e.weightNum, avg: e.runningAverage, id: e._id };
                    });
                    const pointsAvg = chartData.entries.map((e) => {
                      const t = new Date(e.date).getTime();
                      const x = padX + ((t - chartData.minT) / tSpan) * (W - padX - 10);
                      const y =
                        padY + (1 - (e.runningAverage - chartData.minW) / wSpan) * (H - padY - 30);
                      return { x, y, date: e.date, avg: e.runningAverage };
                    });

                    // y axis labels
                    const ticks = 4;
                    const tickVals = Array.from({ length: ticks + 1 }, (_, i) =>
                      +(chartData.minW + (i / ticks) * (chartData.maxW - chartData.minW)).toFixed(1)
                    ).reverse();

                    return (
                      <g>
                        {/* Y grid and labels */}
                        {tickVals.map((val, i) => {
                          const y =
                            padY +
                            (1 - (val - chartData.minW) / (chartData.maxW - chartData.minW || 1)) *
                              (H - padY - 30);
                          return (
                            <g key={i}>
                              <line
                                x1={padX}
                                x2={W - 10}
                                y1={y}
                                y2={y}
                                stroke="#e6e6e6"
                                strokeWidth="1"
                              />
                              <text x={6} y={y + 4} fontSize="10" fill="#666">
                                {val}
                              </text>
                            </g>
                          );
                        })}

                        {/* Avg (trend) path */}
                        <path
                          d={linePath(pointsAvg)}
                          fill="none"
                          stroke="#f97316"
                          strokeWidth="2"
                          strokeLinejoin="round"
                          strokeLinecap="round"
                        />
                        {/* Actual path */}
                        <path
                          d={linePath(pointsActual)}
                          fill="none"
                          stroke="#2563eb"
                          strokeWidth="2"
                          strokeLinejoin="round"
                          strokeLinecap="round"
                        />

                        {/* points */}
                        {pointsActual.map((p) => (
                          <g key={p.id}>
                            <circle
                              cx={p.x}
                              cy={p.y}
                              r={3.5}
                              fill="#2563eb"
                              onMouseEnter={() =>
                                setTooltip({
                                  x: p.x,
                                  y: p.y,
                                  date: p.date,
                                  weight: p.weight,
                                  avg: p.avg
                                })
                              }
                              style={{ cursor: "pointer" }}
                              onClick={() => setSelectedId(p.id)}
                            />
                          </g>
                        ))}

                        {/* hover tooltip */}
                        {tooltip && (
                          <g>
                            <rect
                              x={Math.min(W - 140, tooltip.x + 8)}
                              y={tooltip.y - 36}
                              width="132"
                              height="30"
                              rx="4"
                              fill="white"
                              stroke="#ddd"
                            />
                            <text
                              x={Math.min(W - 130, tooltip.x + 14)}
                              y={tooltip.y - 18}
                              fontSize="11"
                              fill="#111"
                            >
                              {formatDate(tooltip.date)}
                            </text>
                            <text
                              x={Math.min(W - 130, tooltip.x + 14)}
                              y={tooltip.y - 6}
                              fontSize="11"
                              fill="#2563eb"
                            >
                              {`Weight: ${tooltip.weight}`}
                            </text>
                            <text
                              x={Math.min(W - 60, tooltip.x + 84)}
                              y={tooltip.y - 6}
                              fontSize="11"
                              fill="#f97316"
                            >
                              {`Avg: ${tooltip.avg}`}
                            </text>
                          </g>
                        )}
                      </g>
                    );
                  })()
                ) : (
                  <g>
                    <text x="50%" y="50%" textAnchor="middle" fill="#999" fontSize="13">
                      No data to plot
                    </text>
                  </g>
                )}
              </svg>
            </div>
          </div>

          {/* Statistics */}
          {stats && (
            <div className="mb-4 grid grid-cols-2 md:grid-cols-3 gap-3">
              <div className="p-3 bg-blue-50 border border-blue-100 rounded">
                <div className="text-xs text-blue-600 font-semibold mb-1">Current Weight</div>
                <div className="text-lg font-bold text-blue-900">{entriesWithAvgAsc.length > 0 ? entriesWithAvgAsc[entriesWithAvgAsc.length - 1].weightNum.toFixed(1) : '-'}</div>
                <div className="text-xs text-blue-700">{entriesWithAvgAsc.length > 0 ? formatDate(entriesWithAvgAsc[entriesWithAvgAsc.length - 1].date) : 'No data'}</div>
              </div>

              <div className="p-3 bg-orange-50 border border-orange-100 rounded">
                <div className="text-xs text-orange-600 font-semibold mb-1">Trend Weight</div>
                <div className="text-lg font-bold text-orange-900">{entriesWithAvgAsc.length > 0 ? entriesWithAvgAsc[entriesWithAvgAsc.length - 1].runningAverage.toFixed(1) : '-'}</div>
                <div className="text-xs text-orange-700">{entriesWithAvgAsc.length > 0 ? formatDate(entriesWithAvgAsc[entriesWithAvgAsc.length - 1].date) : 'No data'}</div>
              </div>

              <div className="p-3 bg-purple-50 border border-purple-100 rounded">
                <div className="text-xs text-purple-600 font-semibold mb-1">Current Streak</div>
                <div className="text-lg font-bold text-purple-900">{stats.currentStreak} days</div>
                <div className="text-xs text-purple-700">
                  {stats.currentStreak === 0 ? "Log today to start!" : "Keep it up!"}
                </div>
              </div>

              <div className="p-3 bg-pink-50 border border-pink-100 rounded">
                <div className="text-xs text-pink-600 font-semibold mb-1">Highest Weight</div>
                <div className="text-lg font-bold text-pink-900">{stats.highestActual.weightNum.toFixed(1)}</div>
                <div className="text-xs text-pink-700">{formatDate(stats.highestActual.date)}</div>
              </div>

              {calorieDelta && (
                <>
                  <div className="p-3 bg-cyan-50 border border-cyan-100 rounded">
                    <div className="text-xs text-cyan-600 font-semibold mb-1">Calorie Delta</div>
                    <div className="text-lg font-bold text-cyan-900">
                      {calorieDelta.caloriesPerDay > 0 ? '+' : ''}{calorieDelta.caloriesPerDay} cal/day
                    </div>
                    <div className="text-xs text-cyan-700">
                      {calorieDelta.caloriesPerDay > 0 ? 'Surplus' : 'Deficit'}
                    </div>
                  </div>

                  <div className="p-3 bg-indigo-50 border border-indigo-100 rounded">
                    <div className="text-xs text-indigo-600 font-semibold mb-1">Rate of Change</div>
                    <div className="text-lg font-bold text-indigo-900">
                      {calorieDelta.lbsPerWeek > 0 ? '+' : ''}{calorieDelta.lbsPerWeek} lbs/week
                    </div>
                    <div className="text-xs text-indigo-700">7-day trend</div>
                  </div>
                </>
              )}
            </div>
          )}

          {/* Goal Weight Setting */}
          <div className="mb-4 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="p-4 bg-green-50 border border-green-200 rounded">
              <div className="text-sm font-semibold text-green-900 mb-3">Goal Weight</div>
              <div className="flex gap-2 items-end">
                <div className="flex-1">
                  <label className="text-xs text-green-600 block mb-1">Target Weight (lbs)</label>
                  <input
                    type="number"
                    step="0.1"
                    value={goalInput}
                    onChange={(e) => setGoalInput(e.target.value)}
                    placeholder="e.g. 175"
                    className="w-full px-3 py-2 border border-green-300 rounded focus:outline-none focus:ring-2 focus:ring-green-500"
                  />
                </div>
                <button
                  onClick={handleSaveGoal}
                  disabled={!goalInput || isNaN(Number(goalInput))}
                  className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                >
                  Save
                </button>
                {goalWeight && (
                  <button
                    onClick={handleClearGoal}
                    className="px-4 py-2 bg-red-100 text-red-700 rounded hover:bg-red-200 text-sm"
                  >
                    Clear
                  </button>
                )}
              </div>
              {!calorieDelta && goalWeight && (
                <div className="text-xs text-green-700 mt-2">Need at least 7 entries to calculate timeline</div>
              )}
            </div>

            {/* Goal Timeline Projection */}
            {goalProjection && (
              <div className="p-4 bg-green-50 border border-green-200 rounded">
                <div className="text-sm font-semibold text-green-900 mb-3">Goal Timeline</div>
                {goalProjection.wrongDirection ? (
                  <div className="space-y-2 p-3 bg-yellow-50 border border-yellow-200 rounded">
                    <div className="flex justify-between text-sm">
                      <span className="text-yellow-700">Remaining:</span>
                      <span className="font-bold text-yellow-900">{Math.abs(goalProjection.remaining)} lbs to {goalProjection.needToLose ? 'lose' : 'gain'}</span>
                    </div>
                    <div className="text-sm text-yellow-800">
                      <div className="font-semibold mb-1">⚠️ Trending wrong direction</div>
                      <div>Current trend: {goalProjection.currentCalPerDay > 0 ? '+' : ''}{goalProjection.currentCalPerDay} cal/day ({goalProjection.needToLose ? 'gaining' : 'losing'})</div>
                      <div className="mt-1">
                        Need to {goalProjection.needToLose ? 'reduce' : 'increase'} intake by <span className="font-bold">{goalProjection.neededCalChange} cal/day</span> to reverse trend
                      </div>
                    </div>
                  </div>
                ) : (
                  <div className="space-y-2">
                    <div className="flex justify-between text-sm">
                      <span className="text-green-600">Remaining:</span>
                      <span className="font-bold text-green-900">{Math.abs(goalProjection.remaining)} lbs</span>
                    </div>
                    <div className="flex justify-between text-sm">
                      <span className="text-green-600">Estimated Time:</span>
                      <span className="font-bold text-green-900">{goalProjection.daysToGoal} days</span>
                    </div>
                    <div className="flex justify-between text-sm">
                      <span className="text-green-600">Target Date:</span>
                      <span className="font-bold text-green-900">{formatDate(goalProjection.targetDate)}</span>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Table */}
          <div className="overflow-x-auto">
            <table className="w-full border-collapse">
              <thead>
                <tr>
                  <th className="text-left text-xs text-gray-500 pb-2">Date</th>
                  <th className="text-left text-xs text-gray-500 pb-2">Weight</th>
                  <th className="text-left text-xs text-gray-500 pb-2">Running Avg</th>
                </tr>
              </thead>
              <tbody>
                {entriesDesc.length === 0 ? (
                  <tr>
                    <td colSpan="3" className="py-6 text-center text-sm text-gray-500">
                      No entries yet — add one above.
                    </td>
                  </tr>
                ) : (
                  entriesDesc.map((row) => (
                    <tr
                      key={row._id}
                      className={`cursor-pointer hover:bg-gray-50 ${
                        selectedId === row._id ? "bg-gray-100" : ""
                      }`}
                      onClick={() => setSelectedId(row._id)}
                    >
                      <td className="py-2 pr-4">{formatDate(row.date)}</td>
                      <td className="py-2 pr-4">{Number(row.weight).toFixed(1)}</td>
                      <td className="py-2">{Number(row.runningAverage).toFixed(1)}</td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>

          {/* Clear all data button */}
          {entriesDesc.length > 0 && (
            <div className="mt-3 text-right">
              <button
                onClick={handleClearAll}
                className="text-xs px-3 py-1 bg-red-100 text-red-700 rounded hover:bg-red-200"
              >
                Clear All Data
              </button>
            </div>
          )}

          {/* Selected details */}
          {selectedId && (() => {
            const selected = docs.find((d) => d._id === selectedId);
            if (!selected) return null;
            return (
              <div className="mt-4 p-3 border rounded bg-gray-50">
                <div className="flex items-start justify-between">
                  <div>
                    <div className="text-sm text-gray-600">Selected Entry</div>
                    <div className="font-medium">{formatDate(selected.date)}</div>
                    <div className="text-sm">Weight: {Number(selected.weight).toFixed(1)}</div>
                    <div className="text-sm text-gray-500">Created: {new Date(selected.createdAt).toLocaleString()}</div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <button
                      className="text-sm px-3 py-1 bg-red-500 text-white rounded"
                      onClick={() => handleDelete(selected._id)}
                    >
                      Delete
                    </button>
                    <button
                      className="text-sm px-3 py-1 bg-gray-200 rounded"
                      onClick={() => setSelectedId(null)}
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            );
          })()}
        </div>
      </div>
    </div>
  );
}
      // prettier-ignore-end

      const rootElement = document.getElementById("container");
      ReactDOMClient.createRoot(rootElement).render(<App />);
    </script>
    <!--
    Agents see LLMs docs:
      Database: https://use-fireproof.com/llms-full.txt 
      CallAI: https://use-fireproof.com/callai-llms.txt
      ImgGen: https://use-fireproof.com/imggen-llms.txt
    -->
  </body>
</html>
