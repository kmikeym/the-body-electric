<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Made on Vibes DIY</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script>
      window.CALLAI_API_KEY = "sk-vibes-proxy-managed";
      window.CALLAI_CHAT_URL = "https://vibes-diy-api.com/";
      window.CALLAI_IMG_URL = "https://vibes-diy-api.com/";
    </script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.1.1/es2022/react.mjs",
          "react-dom": "https://esm.sh/react-dom@19.1.1/es2022/react-dom.mjs",
          "react-dom/client": "https://esm.sh/react-dom@19.1.1/es2022/client.mjs",
          "use-fireproof": "https://esm.sh/use-fireproof@0.23.14?external=react,react-dom",
          "call-ai": "https://esm.sh/call-ai",
          "use-vibes": "https://esm.sh/use-vibes",
          "three": "https://esm.sh/three"
        }
      }
    </script>
    <script type="text/babel" data-type="module">
      import ReactDOMClient from "react-dom/client";

      // prettier-ignore
      import React, { useMemo, useState, useEffect, useRef } from "react";
import { useFireproof } from "use-fireproof";

export default function App() {
  const { useDocument, useLiveQuery, database } = useFireproof("weight-tracker-db");

  // form document for adding entries
  const today = new Date().toISOString().slice(0, 10);
  const { doc, merge, submit, reset } = useDocument({
    type: "weight-entry",
    date: today,
    weight: "",
    createdAt: Date.now()
  });

  // live query of all docs (we'll filter by type)
  const { docs = [] } = useLiveQuery("date");

  // selected item for detail view
  const [selectedId, setSelectedId] = useState(null);

  // time range filter
  const [timeRange, setTimeRange] = useState("ALL"); // ALL, MONTH, QUARTER, YEAR

  // responsive chart sizing
  const chartRef = useRef();
  const [chartWidth, setChartWidth] = useState(360);
  useEffect(() => {
    function resize() {
      if (chartRef.current) {
        setChartWidth(chartRef.current.clientWidth || 360);
      }
    }
    resize();
    window.addEventListener("resize", resize);
    return () => window.removeEventListener("resize", resize);
  }, []);

  // normalize, sort ascending by date for running average calculation
  const entriesAsc = useMemo(() => {
    const filtered = docs
      .filter((d) => d.type === "weight-entry" && d.weight !== "" && d.date)
      .slice()
      .sort((a, b) => {
        const t = new Date(a.date) - new Date(b.date);
        if (t !== 0) return t;
        return (a._id || "").localeCompare(b._id || "");
      });

    // Apply time range filter
    if (timeRange === "ALL") return filtered;

    const now = new Date();
    const cutoff = new Date();

    if (timeRange === "MONTH") {
      cutoff.setDate(now.getDate() - 30);
    } else if (timeRange === "QUARTER") {
      cutoff.setDate(now.getDate() - 90);
    } else if (timeRange === "YEAR") {
      cutoff.setDate(now.getDate() - 365);
    }

    return filtered.filter(e => new Date(e.date) >= cutoff);
  }, [docs, timeRange]);

  // compute running averages and attach to entries
  const entriesWithAvgAsc = useMemo(() => {
    const result = [];
    let sum = 0;
    for (let i = 0; i < entriesAsc.length; i++) {
      const e = entriesAsc[i];
      const w = Number(e.weight) || 0;
      sum += w;
      const avg = sum / (i + 1);
      result.push({ ...e, runningAverage: Number(avg.toFixed(1)), weightNum: Number(w) });
    }
    return result;
  }, [entriesAsc]);

  // for display we want newest first
  const entriesDesc = useMemo(() => {
    return entriesWithAvgAsc.slice().reverse();
  }, [entriesWithAvgAsc]);

  // chart data: x by time, y by weight
  const chartData = useMemo(() => {
    if (entriesWithAvgAsc.length === 0) return null;
    const times = entriesWithAvgAsc.map((e) => new Date(e.date).getTime());
    const minT = Math.min(...times);
    const maxT = Math.max(...times);
    const weights = entriesWithAvgAsc.map((e) => e.weightNum);
    const avgs = entriesWithAvgAsc.map((e) => e.runningAverage);
    const minW = Math.min(...weights.concat(avgs));
    const maxW = Math.max(...weights.concat(avgs));
    return { entries: entriesWithAvgAsc, minT, maxT, minW, maxW };
  }, [entriesWithAvgAsc]);

  // statistics calculations
  const stats = useMemo(() => {
    if (entriesWithAvgAsc.length === 0) return null;

    // Find highest/lowest actual weight
    let highestActual = entriesWithAvgAsc[0];
    let lowestActual = entriesWithAvgAsc[0];
    let highestTrend = entriesWithAvgAsc[0];
    let lowestTrend = entriesWithAvgAsc[0];

    for (const entry of entriesWithAvgAsc) {
      if (entry.weightNum > highestActual.weightNum) highestActual = entry;
      if (entry.weightNum < lowestActual.weightNum) lowestActual = entry;
      if (entry.runningAverage > highestTrend.runningAverage) highestTrend = entry;
      if (entry.runningAverage < lowestTrend.runningAverage) lowestTrend = entry;
    }

    // Calculate streaks (consecutive days)
    const allEntriesSorted = docs
      .filter((d) => d.type === "weight-entry" && d.weight !== "" && d.date)
      .slice()
      .sort((a, b) => new Date(b.date) - new Date(a.date)); // newest first

    let currentStreak = 0;
    let maxStreak = 0;
    let tempStreak = 1;

    if (allEntriesSorted.length > 0) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const mostRecent = new Date(allEntriesSorted[0].date);
      mostRecent.setHours(0, 0, 0, 0);

      // Check if current streak is active (today or yesterday)
      const daysSinceLastEntry = Math.floor((today - mostRecent) / (1000 * 60 * 60 * 24));
      if (daysSinceLastEntry <= 1) {
        currentStreak = 1;

        // Count consecutive days backwards
        for (let i = 1; i < allEntriesSorted.length; i++) {
          const prevDate = new Date(allEntriesSorted[i - 1].date);
          const currDate = new Date(allEntriesSorted[i].date);
          prevDate.setHours(0, 0, 0, 0);
          currDate.setHours(0, 0, 0, 0);

          const dayDiff = Math.floor((prevDate - currDate) / (1000 * 60 * 60 * 24));
          if (dayDiff === 1) {
            currentStreak++;
          } else {
            break;
          }
        }
      }

      // Find longest streak ever
      for (let i = 0; i < allEntriesSorted.length - 1; i++) {
        const prevDate = new Date(allEntriesSorted[i].date);
        const currDate = new Date(allEntriesSorted[i + 1].date);
        prevDate.setHours(0, 0, 0, 0);
        currDate.setHours(0, 0, 0, 0);

        const dayDiff = Math.floor((prevDate - currDate) / (1000 * 60 * 60 * 24));
        if (dayDiff === 1) {
          tempStreak++;
          maxStreak = Math.max(maxStreak, tempStreak);
        } else {
          tempStreak = 1;
        }
      }
      maxStreak = Math.max(maxStreak, tempStreak, currentStreak);
    }

    return {
      highestActual,
      lowestActual,
      highestTrend,
      lowestTrend,
      currentStreak,
      maxStreak
    };
  }, [entriesWithAvgAsc, docs]);

  // tooltip for chart
  const [tooltip, setTooltip] = useState(null);

  // add entry handler
  const handleAdd = (e) => {
    e.preventDefault();
    if (!doc.date || doc.weight === "" || isNaN(Number(doc.weight))) return;
    merge({ createdAt: Date.now() });
    // submit stores the form doc as a new document and resets the form
    submit();
    // after submit reset date to today for convenience
    setTimeout(() => {
      merge({ date: today, weight: "" });
      reset(); // ensure form cleared
    }, 0);
  };

  // delete entry
  const handleDelete = async (id) => {
    await database.del(id);
    if (selectedId === id) setSelectedId(null);
  };

  // clear all data
  const handleClearAll = async () => {
    if (!confirm("Delete all weight entries? This cannot be undone.")) return;

    const allEntries = docs.filter(d => d.type === "weight-entry");
    for (const entry of allEntries) {
      await database.del(entry._id);
    }
    setSelectedId(null);
  };

  // CSV import handler
  const [importing, setImporting] = useState(false);
  const [importStatus, setImportStatus] = useState(null);

  const handleCSVImport = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    setImporting(true);
    setImportStatus("Reading file...");

    try {
      const text = await file.text();
      const lines = text.split('\n').filter(l => l.trim());

      // Skip header
      const dataLines = lines.slice(1);

      let imported = 0;
      let skipped = 0;

      for (const line of dataLines) {
        const parts = line.split(',');
        if (parts.length < 3) continue;

        const date = parts[0].trim();
        const weight = parts[1].trim();
        const isInterpolated = parts[2].trim();

        // Only import non-interpolated entries
        if (isInterpolated === 'No' && weight && date) {
          await database.put({
            type: "weight-entry",
            date: date,
            weight: weight,
            createdAt: Date.now()
          });
          imported++;
        } else {
          skipped++;
        }
      }

      setImportStatus(`✓ Imported ${imported} entries (skipped ${skipped} interpolated)`);
      setTimeout(() => setImportStatus(null), 5000);

    } catch (err) {
      setImportStatus(`✗ Error: ${err.message}`);
    } finally {
      setImporting(false);
      e.target.value = ''; // Reset file input
    }
  };

  // small helpers
  const formatDate = (d) => {
    return new Date(d).toLocaleDateString();
  };

  // draw path generator for a numeric array -> SVG path
  const linePath = (points) => {
    if (points.length === 0) return "";
    return points
      .map((p, i) => `${i === 0 ? "M" : "L"} ${p.x.toFixed(2)} ${p.y.toFixed(2)}`)
      .join(" ");
  };

  return (
    <div className="min-h-screen p-4 bg-white">
      <div className="max-w-4xl mx-auto">
        <div className="p-5 rounded-lg shadow-sm border border-gray-200">
          <h1 className="text-2xl font-bold mb-2">Weight Tracker</h1>
          <p className="italic text-sm text-gray-600 mb-4">
            Track your weight over time. Add daily entries and view both the raw measurements and a running-average trend line to see longer-term movement.
          </p>

          {/* Input Form */}
          <form onSubmit={handleAdd} className="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
            <div>
              <label className="block text-xs font-semibold mb-1">Date</label>
              <input
                type="date"
                value={doc.date}
                onChange={(e) => merge({ date: e.target.value })}
                className="w-full px-3 py-2 border rounded"
                required
              />
            </div>

            <div>
              <label className="block text-xs font-semibold mb-1">Weight</label>
              <input
                type="number"
                step="0.1"
                min="0"
                value={doc.weight}
                onChange={(e) => merge({ weight: e.target.value })}
                placeholder="e.g. 71.5"
                className="w-full px-3 py-2 border rounded"
                required
              />
            </div>

            <div className="flex items-end">
              <button
                type="submit"
                className="w-full bg-[#2563eb] text-white py-2 rounded hover:bg-[#1e40af]"
              >
                Add Entry
              </button>
            </div>
          </form>

          {/* CSV Import */}
          <div className="mb-4 p-3 border border-dashed border-gray-300 rounded bg-gray-50">
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm font-semibold mb-1">Import from TrendWeight CSV</div>
                <div className="text-xs text-gray-600">Only non-interpolated entries will be imported</div>
              </div>
              <label className="cursor-pointer bg-gray-200 hover:bg-gray-300 px-4 py-2 rounded text-sm font-medium">
                {importing ? "Importing..." : "Choose File"}
                <input
                  type="file"
                  accept=".csv"
                  onChange={handleCSVImport}
                  disabled={importing}
                  className="hidden"
                />
              </label>
            </div>
            {importStatus && (
              <div className={`mt-2 text-sm ${importStatus.startsWith('✓') ? 'text-green-600' : 'text-red-600'}`}>
                {importStatus}
              </div>
            )}
          </div>

          {/* Chart */}
          <div className="mb-4">
            <div className="flex items-center justify-between mb-2">
              <h2 className="font-semibold">Weight & Trend</h2>
              <div className="flex items-center gap-2">
                <div className="text-xs text-gray-600 mr-2">
                  Actual — blue • Trend — orange
                </div>
                <div className="flex gap-1">
                  {["ALL", "MONTH", "QUARTER", "YEAR"].map(range => (
                    <button
                      key={range}
                      onClick={() => setTimeRange(range)}
                      className={`px-2 py-1 text-xs rounded ${
                        timeRange === range
                          ? "bg-[#2563eb] text-white"
                          : "bg-gray-100 text-gray-700 hover:bg-gray-200"
                      }`}
                    >
                      {range === "ALL" ? "All" : range === "MONTH" ? "30d" : range === "QUARTER" ? "90d" : "1y"}
                    </button>
                  ))}
                </div>
              </div>
            </div>

            <div ref={chartRef} className="w-full bg-gray-50 border rounded p-2">
              <svg
                width="100%"
                viewBox={`0 0 ${Math.max(360, chartWidth)} 220`}
                className="block"
                preserveAspectRatio="xMinYMin meet"
                onMouseLeave={() => setTooltip(null)}
              >
                <rect x="0" y="0" width="100%" height="100%" fill="transparent" />
                {chartData ? (
                  (() => {
                    const W = Math.max(360, chartWidth);
                    const H = 200;
                    const padX = 40;
                    const padY = 20;
                    const tSpan = chartData.maxT - chartData.minT || 1;
                    const wSpan = chartData.maxW - chartData.minW || 1;

                    // compute scaled points
                    const pointsActual = chartData.entries.map((e) => {
                      const t = new Date(e.date).getTime();
                      const x = padX + ((t - chartData.minT) / tSpan) * (W - padX - 10);
                      const y =
                        padY + (1 - (e.weightNum - chartData.minW) / wSpan) * (H - padY - 30);
                      return { x, y, date: e.date, weight: e.weightNum, avg: e.runningAverage, id: e._id };
                    });
                    const pointsAvg = chartData.entries.map((e) => {
                      const t = new Date(e.date).getTime();
                      const x = padX + ((t - chartData.minT) / tSpan) * (W - padX - 10);
                      const y =
                        padY + (1 - (e.runningAverage - chartData.minW) / wSpan) * (H - padY - 30);
                      return { x, y, date: e.date, avg: e.runningAverage };
                    });

                    // y axis labels
                    const ticks = 4;
                    const tickVals = Array.from({ length: ticks + 1 }, (_, i) =>
                      +(chartData.minW + (i / ticks) * (chartData.maxW - chartData.minW)).toFixed(1)
                    ).reverse();

                    return (
                      <g>
                        {/* Y grid and labels */}
                        {tickVals.map((val, i) => {
                          const y =
                            padY +
                            (1 - (val - chartData.minW) / (chartData.maxW - chartData.minW || 1)) *
                              (H - padY - 30);
                          return (
                            <g key={i}>
                              <line
                                x1={padX}
                                x2={W - 10}
                                y1={y}
                                y2={y}
                                stroke="#e6e6e6"
                                strokeWidth="1"
                              />
                              <text x={6} y={y + 4} fontSize="10" fill="#666">
                                {val}
                              </text>
                            </g>
                          );
                        })}

                        {/* Avg (trend) path */}
                        <path
                          d={linePath(pointsAvg)}
                          fill="none"
                          stroke="#f97316"
                          strokeWidth="2"
                          strokeLinejoin="round"
                          strokeLinecap="round"
                        />
                        {/* Actual path */}
                        <path
                          d={linePath(pointsActual)}
                          fill="none"
                          stroke="#2563eb"
                          strokeWidth="2"
                          strokeLinejoin="round"
                          strokeLinecap="round"
                        />

                        {/* points */}
                        {pointsActual.map((p) => (
                          <g key={p.id}>
                            <circle
                              cx={p.x}
                              cy={p.y}
                              r={3.5}
                              fill="#2563eb"
                              onMouseEnter={() =>
                                setTooltip({
                                  x: p.x,
                                  y: p.y,
                                  date: p.date,
                                  weight: p.weight,
                                  avg: p.avg
                                })
                              }
                              style={{ cursor: "pointer" }}
                              onClick={() => setSelectedId(p.id)}
                            />
                          </g>
                        ))}

                        {/* hover tooltip */}
                        {tooltip && (
                          <g>
                            <rect
                              x={Math.min(W - 140, tooltip.x + 8)}
                              y={tooltip.y - 36}
                              width="132"
                              height="30"
                              rx="4"
                              fill="white"
                              stroke="#ddd"
                            />
                            <text
                              x={Math.min(W - 130, tooltip.x + 14)}
                              y={tooltip.y - 18}
                              fontSize="11"
                              fill="#111"
                            >
                              {formatDate(tooltip.date)}
                            </text>
                            <text
                              x={Math.min(W - 130, tooltip.x + 14)}
                              y={tooltip.y - 6}
                              fontSize="11"
                              fill="#2563eb"
                            >
                              {`Weight: ${tooltip.weight}`}
                            </text>
                            <text
                              x={Math.min(W - 60, tooltip.x + 84)}
                              y={tooltip.y - 6}
                              fontSize="11"
                              fill="#f97316"
                            >
                              {`Avg: ${tooltip.avg}`}
                            </text>
                          </g>
                        )}
                      </g>
                    );
                  })()
                ) : (
                  <g>
                    <text x="50%" y="50%" textAnchor="middle" fill="#999" fontSize="13">
                      No data to plot
                    </text>
                  </g>
                )}
              </svg>
            </div>
          </div>

          {/* Statistics */}
          {stats && (
            <div className="mb-4 grid grid-cols-2 md:grid-cols-3 gap-3">
              <div className="p-3 bg-blue-50 border border-blue-100 rounded">
                <div className="text-xs text-blue-600 font-semibold mb-1">Highest Weight</div>
                <div className="text-lg font-bold text-blue-900">{stats.highestActual.weightNum.toFixed(1)}</div>
                <div className="text-xs text-blue-700">{formatDate(stats.highestActual.date)}</div>
              </div>

              <div className="p-3 bg-green-50 border border-green-100 rounded">
                <div className="text-xs text-green-600 font-semibold mb-1">Lowest Weight</div>
                <div className="text-lg font-bold text-green-900">{stats.lowestActual.weightNum.toFixed(1)}</div>
                <div className="text-xs text-green-700">{formatDate(stats.lowestActual.date)}</div>
              </div>

              <div className="p-3 bg-orange-50 border border-orange-100 rounded">
                <div className="text-xs text-orange-600 font-semibold mb-1">Highest Trend</div>
                <div className="text-lg font-bold text-orange-900">{stats.highestTrend.runningAverage.toFixed(1)}</div>
                <div className="text-xs text-orange-700">{formatDate(stats.highestTrend.date)}</div>
              </div>

              <div className="p-3 bg-teal-50 border border-teal-100 rounded">
                <div className="text-xs text-teal-600 font-semibold mb-1">Lowest Trend</div>
                <div className="text-lg font-bold text-teal-900">{stats.lowestTrend.runningAverage.toFixed(1)}</div>
                <div className="text-xs text-teal-700">{formatDate(stats.lowestTrend.date)}</div>
              </div>

              <div className="p-3 bg-purple-50 border border-purple-100 rounded">
                <div className="text-xs text-purple-600 font-semibold mb-1">Current Streak</div>
                <div className="text-lg font-bold text-purple-900">{stats.currentStreak} days</div>
                <div className="text-xs text-purple-700">
                  {stats.currentStreak === 0 ? "Log today to start!" : "Keep it up!"}
                </div>
              </div>

              <div className="p-3 bg-pink-50 border border-pink-100 rounded">
                <div className="text-xs text-pink-600 font-semibold mb-1">Best Streak</div>
                <div className="text-lg font-bold text-pink-900">{stats.maxStreak} days</div>
                <div className="text-xs text-pink-700">Personal record</div>
              </div>
            </div>
          )}

          {/* Table */}
          <div className="overflow-x-auto">
            <table className="w-full border-collapse">
              <thead>
                <tr>
                  <th className="text-left text-xs text-gray-500 pb-2">Date</th>
                  <th className="text-left text-xs text-gray-500 pb-2">Weight</th>
                  <th className="text-left text-xs text-gray-500 pb-2">Running Avg</th>
                </tr>
              </thead>
              <tbody>
                {entriesDesc.length === 0 ? (
                  <tr>
                    <td colSpan="3" className="py-6 text-center text-sm text-gray-500">
                      No entries yet — add one above.
                    </td>
                  </tr>
                ) : (
                  entriesDesc.map((row) => (
                    <tr
                      key={row._id}
                      className={`cursor-pointer hover:bg-gray-50 ${
                        selectedId === row._id ? "bg-gray-100" : ""
                      }`}
                      onClick={() => setSelectedId(row._id)}
                    >
                      <td className="py-2 pr-4">{formatDate(row.date)}</td>
                      <td className="py-2 pr-4">{Number(row.weight).toFixed(1)}</td>
                      <td className="py-2">{Number(row.runningAverage).toFixed(1)}</td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>

          {/* Clear all data button */}
          {entriesDesc.length > 0 && (
            <div className="mt-3 text-right">
              <button
                onClick={handleClearAll}
                className="text-xs px-3 py-1 bg-red-100 text-red-700 rounded hover:bg-red-200"
              >
                Clear All Data
              </button>
            </div>
          )}

          {/* Selected details */}
          {selectedId && (() => {
            const selected = docs.find((d) => d._id === selectedId);
            if (!selected) return null;
            return (
              <div className="mt-4 p-3 border rounded bg-gray-50">
                <div className="flex items-start justify-between">
                  <div>
                    <div className="text-sm text-gray-600">Selected Entry</div>
                    <div className="font-medium">{formatDate(selected.date)}</div>
                    <div className="text-sm">Weight: {Number(selected.weight).toFixed(1)}</div>
                    <div className="text-sm text-gray-500">Created: {new Date(selected.createdAt).toLocaleString()}</div>
                  </div>
                  <div className="flex items-center space-x-2">
                    <button
                      className="text-sm px-3 py-1 bg-red-500 text-white rounded"
                      onClick={() => handleDelete(selected._id)}
                    >
                      Delete
                    </button>
                    <button
                      className="text-sm px-3 py-1 bg-gray-200 rounded"
                      onClick={() => setSelectedId(null)}
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            );
          })()}
        </div>
      </div>
    </div>
  );
}
      // prettier-ignore-end

      const rootElement = document.getElementById("container");
      ReactDOMClient.createRoot(rootElement).render(<App />);
    </script>
    <!--
    Agents see LLMs docs:
      Database: https://use-fireproof.com/llms-full.txt 
      CallAI: https://use-fireproof.com/callai-llms.txt
      ImgGen: https://use-fireproof.com/imggen-llms.txt
    -->
  </body>
</html>
